{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_19-f1eed25605bd9eb58bd24a7d9149b4b4743da81f",
  "solcVersion": "0.8.19",
  "solcLongVersion": "0.8.19+commit.7dd6d404",
  "userSourceNameMap": {
    "contracts/PistolPoniesAdSpace.sol": "project/contracts/PistolPoniesAdSpace.sol",
    "contracts/PistolPoniesGameSave.sol": "project/contracts/PistolPoniesGameSave.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "paris",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/PistolPoniesAdSpace.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title PistolPoniesAdSpace\n * @dev Automated queue-based marketplace for purchasing ad slots on in-game walls.\n * \n * Recommended Ad Image Size: 1200 x 630 pixels (1.9:1 ratio)\n * Supported formats: PNG, JPG, WebP\n * \n * 16 parallel tracks: Ads are automatically queued to the track that opens up soonest.\n */\ncontract PistolPoniesAdSpace {\n    address public owner;\n    uint256 public slotPrice; // Price per hour in wei\n    \n    struct Ad {\n        address owner;\n        string imageUrl;\n        uint256 startTime;\n        uint256 endTime;\n    }\n    \n    // 16 independent ad tracks (queues)\n    mapping(uint256 => Ad[]) public trackQueues;\n    \n    // The timestamp when each track will next be free\n    uint256[16] public trackEndTimes;\n    \n    uint256 public constant TOTAL_TRACKS = 16;\n    \n    // Events\n    event AdQueued(uint256 indexed trackIndex, address indexed buyer, string imageUrl, uint256 startTime, uint256 endTime);\n    event SlotPriceUpdated(uint256 newPrice);\n    event AdRemoved(uint256 indexed trackIndex, uint256 adIndex);\n    event FundsWithdrawn(address indexed to, uint256 amount);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n    \n    constructor(uint256 _initialPrice) {\n        owner = msg.sender;\n        slotPrice = _initialPrice; // ~0.00001389 ETH per hour\n        \n        // Initialize track end times to current timestamp\n        for (uint256 i = 0; i < TOTAL_TRACKS; i++) {\n            trackEndTimes[i] = block.timestamp;\n        }\n    }\n    \n    /**\n     * @dev Purchase an ad and automatically queue it to the best available track\n     * @param imageUrl HTTPS URL to the ad image\n     */\n    function buyAd(string calldata imageUrl) external payable {\n        require(msg.value >= slotPrice, \"Insufficient payment (min 1 hour)\");\n        require(bytes(imageUrl).length > 0 && bytes(imageUrl).length <= 256, \"Invalid URL\");\n        \n        uint256 hoursPurchased = msg.value / slotPrice;\n        uint256 duration = hoursPurchased * 1 hours;\n        uint256 cost = hoursPurchased * slotPrice;\n        \n        // Find the track that becomes available SOONEST\n        uint256 bestTrack = 0;\n        uint256 earliestEnd = trackEndTimes[0];\n        \n        for (uint256 i = 1; i < TOTAL_TRACKS; i++) {\n            if (trackEndTimes[i] < earliestEnd) {\n                earliestEnd = trackEndTimes[i];\n                bestTrack = i;\n            }\n        }\n        \n        // Calculate start time: either now (if track is empty) or when current last ad ends\n        uint256 startTime = trackEndTimes[bestTrack] > block.timestamp ? trackEndTimes[bestTrack] : block.timestamp;\n        uint256 endTime = startTime + duration;\n        \n        // Add to queue\n        trackQueues[bestTrack].push(Ad({\n            owner: msg.sender,\n            imageUrl: imageUrl,\n            startTime: startTime,\n            endTime: endTime\n        }));\n        \n        // Update track end time\n        trackEndTimes[bestTrack] = endTime;\n        \n        emit AdQueued(bestTrack, msg.sender, imageUrl, startTime, endTime);\n        \n        // Refund fraction of an hour payment\n        if (msg.value > cost) {\n            payable(msg.sender).transfer(msg.value - cost);\n        }\n    }\n    \n    /**\n     * @dev Get the 16 ads currently active across all tracks\n     */\n    function getActiveAds() external view returns (\n        address[16] memory owners,\n        string[16] memory imageUrls,\n        uint256[16] memory endTimes\n    ) {\n        for (uint256 i = 0; i < TOTAL_TRACKS; i++) {\n            Ad[] storage queue = trackQueues[i];\n            \n            // Look for the ad that is currently active\n            bool found = false;\n            for (uint256 j = 0; j < queue.length; j++) {\n                if (block.timestamp >= queue[j].startTime && block.timestamp < queue[j].endTime) {\n                    owners[i] = queue[j].owner;\n                    imageUrls[i] = queue[j].imageUrl;\n                    endTimes[i] = queue[j].endTime;\n                    found = true;\n                    break;\n                }\n            }\n            \n            // If no ad found, defaults (empty string, zero address) will be returned\n        }\n        return (owners, imageUrls, endTimes);\n    }\n    \n    /**\n     * @dev Get full queue for a specific track\n     */\n    function getTrackQueue(uint256 trackIndex) external view returns (Ad[] memory) {\n        require(trackIndex < TOTAL_TRACKS, \"Invalid track\");\n        return trackQueues[trackIndex];\n    }\n    \n    /**\n     * @dev Get all ads owned by a specific user (convenience for dashboard)\n     */\n    function getMyAds(address user) external view returns (\n        uint256[] memory trackIndices,\n        string[] memory imageUrls,\n        uint256[] memory startTimes,\n        uint256[] memory endTimes\n    ) {\n        uint256 count = 0;\n        \n        // First pass: count user ads\n        for (uint256 i = 0; i < TOTAL_TRACKS; i++) {\n            Ad[] storage queue = trackQueues[i];\n            for (uint256 j = 0; j < queue.length; j++) {\n                if (queue[j].owner == user && queue[j].endTime > block.timestamp) {\n                    count++;\n                }\n            }\n        }\n        \n        trackIndices = new uint256[](count);\n        imageUrls = new string[](count);\n        startTimes = new uint256[](count);\n        endTimes = new uint256[](count);\n        \n        uint256 idx = 0;\n        for (uint256 i = 0; i < TOTAL_TRACKS; i++) {\n            Ad[] storage queue = trackQueues[i];\n            for (uint256 j = 0; j < queue.length; j++) {\n                if (queue[j].owner == user && queue[j].endTime > block.timestamp) {\n                    trackIndices[idx] = i;\n                    imageUrls[idx] = queue[j].imageUrl;\n                    startTimes[idx] = queue[j].startTime;\n                    endTimes[idx] = queue[j].endTime;\n                    idx++;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Get availability: when each track will next be free\n     */\n    function getAvailability() external view returns (uint256[16] memory) {\n        return trackEndTimes;\n    }\n    \n    /**\n     * @dev Update slot price (owner only)\n     */\n    function setSlotPrice(uint256 newPrice) external onlyOwner {\n        slotPrice = newPrice;\n        emit SlotPriceUpdated(newPrice);\n    }\n    \n    /**\n     * @dev Withdraw contract funds (owner only)\n     */\n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No funds\");\n        payable(owner).transfer(balance);\n        emit FundsWithdrawn(owner, balance);\n    }\n    \n    /**\n     * @dev Remove an ad (owner only, for moderation)\n     * Decrements endTimes of subsequent ads in that track if needed\n     */\n    function removeAd(uint256 trackIndex, uint256 adIndex) external onlyOwner {\n        require(trackIndex < TOTAL_TRACKS, \"Invalid track\");\n        Ad[] storage queue = trackQueues[trackIndex];\n        require(adIndex < queue.length, \"Invalid ad index\");\n        \n        // For simplicity: just expire it now\n        queue[adIndex].endTime = block.timestamp;\n        \n        emit AdRemoved(trackIndex, adIndex);\n    }\n    \n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid address\");\n        owner = newOwner;\n    }\n}\n"
      },
      "project/contracts/PistolPoniesGameSave.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title PistolPoniesGameSave\n * @dev Extensible on-chain game save storage with micro-fee\n * \n * Supports flexible data storage with versioning for future updates:\n * - Core stats (name, kills, deaths, level)\n * - Skill stats (speed, health, ammo, jump, dash, aim)\n * - Inventory (weapons, items as encoded data)\n * - Achievements (badge IDs)\n * - Settings (player preferences as encoded data)\n * - Match history (wins, losses, playtime)\n * - Cosmetics (skins, colors, accessories)\n * \n * Uses key-value storage for extensibility - new data types can be added\n * without contract redeployment.\n */\ncontract PistolPoniesGameSave {\n    address public owner;\n    uint256 public saveFee;\n    uint256 public currentVersion;\n    \n    // Core player data (always present)\n    struct CoreStats {\n        string name;\n        uint256 kills;\n        uint256 deaths;\n        uint256 level;\n        uint256 xp;\n        uint256 savedAt;\n        uint256 version;\n    }\n    \n    // Skill points allocation\n    struct SkillStats {\n        uint8 speed;\n        uint8 health;\n        uint8 ammo;\n        uint8 jump;\n        uint8 dash;\n        uint8 aim;\n        uint8 skillPoints; // Unallocated points\n    }\n    \n    // Match statistics\n    struct MatchStats {\n        uint256 wins;\n        uint256 losses;\n        uint256 totalPlaytime; // In seconds\n        uint256 highestKillStreak;\n        uint256 headshotKills;\n    }\n    \n    // Storage mappings\n    mapping(address => CoreStats) public coreStats;\n    mapping(address => SkillStats) public skillStats;\n    mapping(address => MatchStats) public matchStats;\n    \n    // Flexible key-value storage for extensibility\n    // Key format: keccak256(abi.encodePacked(category, subkey))\n    mapping(address => mapping(bytes32 => bytes)) public playerData;\n    \n    // Category constants for organized storage\n    bytes32 public constant CAT_INVENTORY = keccak256(\"inventory\");\n    bytes32 public constant CAT_ACHIEVEMENTS = keccak256(\"achievements\");\n    bytes32 public constant CAT_SETTINGS = keccak256(\"settings\");\n    bytes32 public constant CAT_COSMETICS = keccak256(\"cosmetics\");\n    bytes32 public constant CAT_CUSTOM = keccak256(\"custom\");\n    \n    // Track all players who have saved\n    address[] public players;\n    mapping(address => bool) public hasPlayed;\n    \n    // Events\n    event GameSaved(address indexed player, string name, uint256 level, uint256 version);\n    event DataUpdated(address indexed player, bytes32 indexed category, bytes32 key);\n    event SaveFeeUpdated(uint256 newFee);\n    event FundsWithdrawn(address indexed to, uint256 amount);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n    \n    constructor(uint256 _initialFee) {\n        owner = msg.sender;\n        saveFee = _initialFee; // ~0.00005 ETH\n        currentVersion = 1;\n    }\n    \n    // ===== CORE SAVE FUNCTIONS =====\n    \n    /**\n     * @dev Save all game data at once (most common use case)\n     */\n    function saveGame(\n        string calldata name,\n        uint256 kills,\n        uint256 deaths,\n        uint256 level,\n        uint256 xp,\n        uint8[7] calldata skills, // [speed, health, ammo, jump, dash, aim, skillPoints]\n        uint256[5] calldata matches // [wins, losses, playtime, killStreak, headshots]\n    ) external payable {\n        require(msg.value >= saveFee, \"Insufficient fee\");\n        require(bytes(name).length > 0 && bytes(name).length <= 20, \"Invalid name\");\n        \n        // Save core stats\n        CoreStats storage core = coreStats[msg.sender];\n        core.name = name;\n        core.kills = kills;\n        core.deaths = deaths;\n        core.level = level;\n        core.xp = xp;\n        core.savedAt = block.timestamp;\n        core.version = currentVersion;\n        \n        // Save skill stats\n        SkillStats storage skill = skillStats[msg.sender];\n        skill.speed = skills[0];\n        skill.health = skills[1];\n        skill.ammo = skills[2];\n        skill.jump = skills[3];\n        skill.dash = skills[4];\n        skill.aim = skills[5];\n        skill.skillPoints = skills[6];\n        \n        // Save match stats\n        MatchStats storage match_ = matchStats[msg.sender];\n        match_.wins = matches[0];\n        match_.losses = matches[1];\n        match_.totalPlaytime = matches[2];\n        match_.highestKillStreak = matches[3];\n        match_.headshotKills = matches[4];\n        \n        // Track player if first save\n        if (!hasPlayed[msg.sender]) {\n            hasPlayed[msg.sender] = true;\n            players.push(msg.sender);\n        }\n        \n        emit GameSaved(msg.sender, name, level, currentVersion);\n        \n        // Refund excess\n        if (msg.value > saveFee) {\n            payable(msg.sender).transfer(msg.value - saveFee);\n        }\n    }\n    \n    /**\n     * @dev Save flexible data (inventory, achievements, cosmetics, etc.)\n     * @param category Category constant (CAT_INVENTORY, CAT_ACHIEVEMENTS, etc.)\n     * @param key Subkey within category (e.g., \"weapons\", \"badges\")\n     * @param data Encoded data (use abi.encode on frontend)\n     */\n    function saveData(bytes32 category, bytes32 key, bytes calldata data) external payable {\n        require(msg.value >= saveFee, \"Insufficient fee\");\n        require(data.length > 0 && data.length <= 8192, \"Invalid data size\");\n        \n        bytes32 storageKey = keccak256(abi.encodePacked(category, key));\n        playerData[msg.sender][storageKey] = data;\n        \n        // Update save timestamp\n        coreStats[msg.sender].savedAt = block.timestamp;\n        \n        emit DataUpdated(msg.sender, category, key);\n        \n        if (msg.value > saveFee) {\n            payable(msg.sender).transfer(msg.value - saveFee);\n        }\n    }\n    \n    /**\n     * @dev Batch save multiple data entries (costs 1 fee total)\n     */\n    function saveDataBatch(\n        bytes32[] calldata categories,\n        bytes32[] calldata keys,\n        bytes[] calldata dataArray\n    ) external payable {\n        require(msg.value >= saveFee, \"Insufficient fee\");\n        require(categories.length == keys.length && keys.length == dataArray.length, \"Length mismatch\");\n        require(categories.length <= 10, \"Too many items\");\n        \n        for (uint256 i = 0; i < categories.length; i++) {\n            bytes32 storageKey = keccak256(abi.encodePacked(categories[i], keys[i]));\n            playerData[msg.sender][storageKey] = dataArray[i];\n            emit DataUpdated(msg.sender, categories[i], keys[i]);\n        }\n        \n        coreStats[msg.sender].savedAt = block.timestamp;\n        \n        if (msg.value > saveFee) {\n            payable(msg.sender).transfer(msg.value - saveFee);\n        }\n    }\n    \n    // ===== LOAD FUNCTIONS (FREE) =====\n    \n    /**\n     * @dev Load all core game data\n     */\n    function loadGame(address player) external view returns (\n        CoreStats memory core,\n        SkillStats memory skills,\n        MatchStats memory matches\n    ) {\n        return (coreStats[player], skillStats[player], matchStats[player]);\n    }\n    \n    /**\n     * @dev Load flexible data\n     */\n    function loadData(address player, bytes32 category, bytes32 key) external view returns (bytes memory) {\n        bytes32 storageKey = keccak256(abi.encodePacked(category, key));\n        return playerData[player][storageKey];\n    }\n    \n    /**\n     * @dev Check if player has any saved data\n     */\n    function hasSavedGame(address player) external view returns (bool) {\n        return coreStats[player].savedAt > 0;\n    }\n    \n    /**\n     * @dev Get save version for migration support\n     */\n    function getSaveVersion(address player) external view returns (uint256) {\n        return coreStats[player].version;\n    }\n    \n    // ===== LEADERBOARD =====\n    \n    /**\n     * @dev Get total players count\n     */\n    function getTotalPlayers() external view returns (uint256) {\n        return players.length;\n    }\n    \n    /**\n     * @dev Get leaderboard (top N by kills)\n     */\n    function getLeaderboard(uint256 limit) external view returns (\n        address[] memory addresses,\n        string[] memory names,\n        uint256[] memory killCounts,\n        uint256[] memory levels\n    ) {\n        uint256 count = players.length < limit ? players.length : limit;\n        \n        // Simple implementation - for large player counts, use off-chain indexing\n        address[] memory sortedAddrs = new address[](players.length);\n        uint256[] memory sortedKills = new uint256[](players.length);\n        \n        for (uint256 i = 0; i < players.length; i++) {\n            sortedAddrs[i] = players[i];\n            sortedKills[i] = coreStats[players[i]].kills;\n        }\n        \n        // Bubble sort (fine for small arrays)\n        for (uint256 i = 0; i < players.length && i < limit; i++) {\n            for (uint256 j = i + 1; j < players.length; j++) {\n                if (sortedKills[j] > sortedKills[i]) {\n                    (sortedKills[i], sortedKills[j]) = (sortedKills[j], sortedKills[i]);\n                    (sortedAddrs[i], sortedAddrs[j]) = (sortedAddrs[j], sortedAddrs[i]);\n                }\n            }\n        }\n        \n        addresses = new address[](count);\n        names = new string[](count);\n        killCounts = new uint256[](count);\n        levels = new uint256[](count);\n        \n        for (uint256 i = 0; i < count; i++) {\n            addresses[i] = sortedAddrs[i];\n            names[i] = coreStats[sortedAddrs[i]].name;\n            killCounts[i] = sortedKills[i];\n            levels[i] = coreStats[sortedAddrs[i]].level;\n        }\n    }\n    \n    // ===== ADMIN FUNCTIONS =====\n    \n    function setSaveFee(uint256 newFee) external onlyOwner {\n        saveFee = newFee;\n        emit SaveFeeUpdated(newFee);\n    }\n    \n    function setVersion(uint256 newVersion) external onlyOwner {\n        currentVersion = newVersion;\n    }\n    \n    function withdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No funds\");\n        payable(owner).transfer(balance);\n        emit FundsWithdrawn(owner, balance);\n    }\n    \n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid address\");\n        owner = newOwner;\n    }\n}\n"
      }
    }
  }
}